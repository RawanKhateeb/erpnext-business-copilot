"""
FastAPI application entry point.
Routes requests to appropriate controllers.
"""
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.requests import Request
import os
import logging

# Import routers (controllers)
from app.controllers import (
    data_router,
    copilot_router,
    export_router,
    ai_router,
)

logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="ERPNext Business Copilot",
    description="AI-powered assistant for ERPNext business data",
    version="1.0.0"
)

# Set up Jinja2 templates
templates_dir = os.path.join(os.path.dirname(__file__), "templates")
templates = Jinja2Templates(directory=templates_dir)

# Include all routers (controllers)
app.include_router(data_router)
app.include_router(copilot_router)
app.include_router(export_router)
app.include_router(ai_router)


@app.get("/")
def root(request: Request):
    """Serve the Copilot UI homepage."""
    return templates.TemplateResponse("copilot.html", {"request": request})


@app.get("/health")
def health():
    """Health check endpoint."""
    return {"status": "ok"}


# Mount static files if they exist
static_dir = os.path.join(os.path.dirname(__file__), "static")
if os.path.exists(static_dir):
    app.mount("/static", StaticFiles(directory=static_dir), name="static")


@app.get("/")
def root(request: Request):
    """Serve the Copilot UI homepage."""
    return templates.TemplateResponse("copilot.html", {"request": request})


@app.get("/health")
def health():
    return {"status": "ok"}


@app.get("/suppliers")
def suppliers():
    try:
        return {"data": get_client().list_suppliers()}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/items")
def items():
    try:
        return {"data": get_client().list_items()}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/purchase-orders")
def purchase_orders(limit: int = 20):
    try:
        return {"data": get_client().list_purchase_orders(limit=limit)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/purchase-orders/{po_name}")
def purchase_order(po_name: str):
    try:
        return {"data": get_client().get_purchase_order(po_name)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class CopilotRequest(BaseModel):
    query: str

@app.post("/copilot")
def copilot(req: CopilotRequest):
    return handle_user_input(req.query)

@app.post("/copilot/ask")
def copilot_ask(req: CopilotRequest):
    """
    Copilot endpoint: Parse intent and fetch relevant data.
    
    Request: POST /copilot/ask
    Body: { "query": "What suppliers do we have?" }
    
    Response:
    {
        "intent": "list_suppliers",
        "message": "Found 5 suppliers.",
        "data": [...]
    }
    """
    return handle_user_input(req.query)


class ExportRequest(BaseModel):
    data: dict
    intent: str = "report"
    title: str = "ERPNext Copilot Report"


@app.post("/export/pdf")
def export_pdf(req: ExportRequest):
    """
    Export copilot response data as PDF.
    
    Request: POST /export/pdf
    Body: {
        "data": { ... copilot response data ... },
        "intent": "detect_price_anomalies",
        "title": "Price Anomaly Report"
    }
    
    Returns: PDF file download
    """
    try:
        # Extract the data to export
        export_data = req.data.get('data') or req.data
        
        # Generate PDF
        pdf_bytes = generate_pdf_report(
            data=export_data,
            intent=req.intent,
            title=req.title
        )
        
        # Return as downloadable file
        filename = f"copilot_report_{req.intent}.pdf"
        return StreamingResponse(
            iter([pdf_bytes]),
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={filename}"}
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"PDF generation failed: {str(e)}")


class AIReportRequest(BaseModel):
    query: str


@app.post("/ai/report")
def ai_report(req: AIReportRequest):
    """
    Generate AI-powered procurement report using OpenAI.
    
    Request: POST /ai/report
    Body: {"query": "Generate monthly procurement report"}
    
    Returns: {
        "success": true,
        "intent": "ai_report",
        "answer": "Narrative report text",
        "ai_generated": true,
        "summary": {...}
    }
    """
    try:
        logger.info(f"AI Report request: {req.query}")
        
        # Step 1: Fetch purchase orders from ERPNext
        try:
            client = get_client()
            pos = client.list_purchase_orders()
            logger.info(f"Fetched {len(pos) if pos else 0} purchase orders")
        except Exception as e:
            logger.error(f"ERPNext fetch error: {str(e)}")
            pos = []
        
        if not pos:
            logger.warning("No purchase orders found")
            return {
                "success": False,
                "message": "No purchase order data available",
                "intent": "ai_report",
                "ai_generated": True
            }
        
        # Step 2: Compute summary statistics
        try:
            summary = _compute_po_summary(pos)
            summary['date_range'] = 'This Period'
            logger.info(f"Summary computed: {summary['po_count']} orders, ${summary['total_spend']} total spend")
        except Exception as e:
            logger.error(f"Summary computation error: {str(e)}")
            return {
                "success": False,
                "message": f"Error computing summary: {str(e)}",
                "intent": "ai_report",
                "ai_generated": True
            }
        
        # Step 3: Generate AI report
        try:
            logger.info("Creating AIReportGenerator...")
            ai_gen = AIReportGenerator()
            logger.info("AIReportGenerator created, calling generate_procurement_report...")
            
            result = ai_gen.generate_procurement_report(summary, req.query)
            logger.info(f"AI generation result: success={result.get('success')}")
            
            if result.get('success'):
                logger.info("Report generated successfully")
                return {
                    "success": True,
                    "intent": "ai_report",
                    "answer": result['report'],
                    "ai_generated": True,
                    "summary": result['summary'],
                    "generated_at": result['generated_at']
                }
            else:
                error_msg = result.get('message', 'AI service unavailable')
                logger.error(f"AI Report generation failed: {error_msg}")
                return {
                    "success": False,
                    "message": error_msg,
                    "intent": "ai_report",
                    "ai_generated": True,
                    "error": result.get('error')
                }
        
        except ImportError as e:
            logger.error(f"OpenAI import error: {str(e)}")
            return {
                "success": False,
                "message": "OpenAI library not installed",
                "intent": "ai_report",
                "ai_generated": True
            }
        except Exception as e:
            logger.error(f"AI generation exception: {type(e).__name__}: {str(e)}", exc_info=True)
            return {
                "success": False,
                "message": f"AI generation failed: {str(e)}",
                "intent": "ai_report",
                "ai_generated": True
            }
    
    except Exception as e:
        logger.error(f"AI Report endpoint critical error: {type(e).__name__}: {str(e)}", exc_info=True)
        return {
            "success": False,
            "message": f"Critical error: {str(e)}",
            "intent": "ai_report",
            "ai_generated": True
        }


def _compute_po_summary(pos: list) -> dict:
    """
    Compute summary statistics from purchase orders.
    
    Args:
        pos: List of purchase order dictionaries
    
    Returns:
        Dictionary with summary statistics
    """
    total_spend = 0
    pending_count = 0
    status_breakdown = {}
    suppliers = {}
    
    for po in pos:
        # Sum spending
        amount = po.get('grand_total', 0)
        if isinstance(amount, (int, float)):
            total_spend += amount
        
        # Count pending
        status = po.get('status', 'Unknown')
        if status.lower() in ['pending', 'draft']:
            pending_count += 1
        
        # Status breakdown
        status_breakdown[status] = status_breakdown.get(status, 0) + 1
        
        # Supplier spending
        supplier = po.get('supplier', 'Unknown')
        suppliers[supplier] = suppliers.get(supplier, 0) + amount
    
    # Get top 5 suppliers
    top_suppliers = sorted(
        suppliers.items(),
        key=lambda x: x[1],
        reverse=True
    )[:5]
    
    return {
        'total_spend': total_spend,
        'po_count': len(pos),
        'pending_count': pending_count,
        'status_breakdown': status_breakdown,
        'top_suppliers': top_suppliers
    }